<?php
// DO NOT EDIT! Generated by Protobuf-PHP protoc plugin @package_version@// Source: riak.proto
//   Date: 2015-01-16 03:40:25


namespace Riak\Client\ProtoBuf {

    class DtUpdateResp extends \DrSlump\Protobuf\Message
    {
        /** @var \DrSlump\Protobuf\Descriptor */
        protected static $__descriptor;
        /** @var \Closure[] */
        protected static $__extensions = array();

        public static function descriptor()
        {
            $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, '.DtUpdateResp');

            // optional bytes key = 1
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 1;
            $f->name   = "key";
            $f->rule   = \DrSlump\Protobuf\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf\Protobuf::TYPE_BYTES;

            $descriptor->addField($f);

            // optional bytes context = 2
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 2;
            $f->name   = "context";
            $f->rule   = \DrSlump\Protobuf\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf\Protobuf::TYPE_BYTES;

            $descriptor->addField($f);

            // optional sint64 counter_value = 3
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 3;
            $f->name   = "counter_value";
            $f->rule   = \DrSlump\Protobuf\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf\Protobuf::TYPE_SINT64;

            $descriptor->addField($f);

            // repeated bytes set_value = 4
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 4;
            $f->name   = "set_value";
            $f->rule   = \DrSlump\Protobuf\Protobuf::RULE_REPEATED;
            $f->type   = \DrSlump\Protobuf\Protobuf::TYPE_BYTES;

            $descriptor->addField($f);

            // repeated message map_value = 5
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 5;
            $f->name   = "map_value";
            $f->rule   = \DrSlump\Protobuf\Protobuf::RULE_REPEATED;
            $f->type   = \DrSlump\Protobuf\Protobuf::TYPE_MESSAGE;

            $f->reference = '\Riak\Client\ProtoBuf\MapEntry';

            $descriptor->addField($f);

            foreach (self::$__extensions as $cb) {
                $descriptor->addField($cb(), true);
            }

            return $descriptor;
        }

        /**
         * Check if "key" has a value
         *
         * @return boolean
         */
        public function hasKey()
        {
            return isset($this->key);
        }

        /**
         * Clear "key" value
         */
        public function clearKey()
        {
            unset($this->key);
        }

        /**
         * Get "key" value
         * @return \PhpOption\Option of type (string)
         *
         *
         */
        public function getKey()
        {
            return \PhpOption\Option::fromValue($this->key);
        }

        /**
         * Set "key" value
         *
         * @param string $value
         */
        public function setKey($value)
        {
            return $this->key = $value;
        }

        /**
         * Check if "context" has a value
         *
         * @return boolean
         */
        public function hasContext()
        {
            return isset($this->context);
        }

        /**
         * Clear "context" value
         */
        public function clearContext()
        {
            unset($this->context);
        }

        /**
         * Get "context" value
         * @return \PhpOption\Option of type (string)
         *
         *
         */
        public function getContext()
        {
            return \PhpOption\Option::fromValue($this->context);
        }

        /**
         * Set "context" value
         *
         * @param string $value
         */
        public function setContext($value)
        {
            return $this->context = $value;
        }

        /**
         * Check if "counter_value" has a value
         *
         * @return boolean
         */
        public function hasCounterValue()
        {
            return isset($this->counter_value);
        }

        /**
         * Clear "counter_value" value
         */
        public function clearCounterValue()
        {
            unset($this->counter_value);
        }

        /**
         * Get "counter_value" value
         * @return \PhpOption\Option of type (int)
         *
         *
         */
        public function getCounterValue()
        {
            return \PhpOption\Option::fromValue($this->counter_value);
        }

        /**
         * Set "counter_value" value
         *
         * @param int $value
         */
        public function setCounterValue($value)
        {
            return $this->counter_value = $value;
        }

        /**
         * Check if "set_value" has a value
         *
         * @return boolean
         */
        public function hasSetValue()
        {
            return isset($this->set_value);
        }

        /**
         * Clear "set_value" value
         */
        public function clearSetValue()
        {
            unset($this->set_value);
        }

        /**
         * Get "set_value" value
         *
         * @return \PhpOption\Option of type string[]
         */
        public function getSetValue($idx = null)
        {
            if (null == $idx || !array_key_exists($idx, $this->set_value)) {
                return  \PhpOption\None::create();
            }

            return new \PhpOption\Some($this->set_value[$idx]);
        }

        /**
         * Get "set_value" list of values
         *
         * @return string[]
         */
        public function getSetValueList()
        {
            return $this->set_value;
        }

        /**
         * Set "set_value" value
         *
         * @param string[] $value
         */
        public function setSetValue($value)
        {
            return $this->set_value = $value;
        }

        /**
         * Add a new element to "set_value"
         *
         * @param string $value
         */
        public function addSetValue($value)
        {
            $this->set_value[] = $value;
        }

        /**
         * Check if "map_value" has a value
         *
         * @return boolean
         */
        public function hasMapValue()
        {
            return isset($this->map_value);
        }

        /**
         * Clear "map_value" value
         */
        public function clearMapValue()
        {
            unset($this->map_value);
        }

        /**
         * Get "map_value" value
         *
         * @return \PhpOption\Option of type MapEntry[]
         */
        public function getMapValue($idx = null)
        {
            if (null == $idx || !array_key_exists($idx, $this->map_value)) {
                return  \PhpOption\None::create();
            }

            return new \PhpOption\Some($this->map_value[$idx]);
        }

        /**
         * Get "map_value" list of values
         *
         * @return MapEntry[]
         */
        public function getMapValueList()
        {
            return $this->map_value;
        }

        /**
         * Set "map_value" value
         *
         * @param MapEntry[] $value
         */
        public function setMapValue($value)
        {
            return $this->map_value = $value;
        }

        /**
         * Add a new element to "map_value"
         *
         * @param MapEntry $value
         */
        public function addMapValue($value)
        {
            $this->map_value[] = $value;
        }
    }
}
